---
layout: post
published: true
title: JVM Platform Usefulness
---

I have been reacquainting myself with some of the JVM internals. None of this knowledge directly changes how I work day to day, but it's still useful to know when the situation arises. I'm writing this one so I have a nice summary for myself. For a good read that covers these topics in more detail, I suggest reading "The Well-Grounded Java Developer - Evans & Verburg."

Classloading
=============
Classloading is the process by which the JVM loads custom code and types. When you compile your *.java source, you end up with *.class files. These *.class file contain bytecode, which I'll talk more about in a bit. For the JVM to create a new instance of your custom type, the .class file needs to be loaded and linked. Loading happens when the JVM reads the byte stream from disk that lives in the .class file, and then creates an instance of the 'Class' type. The next step is Linking, which happens in 4 phases (Verification, Preparation, Resolution, and Initialization). Verification checks things such access controls, type validations, and bytecode stack checks. Once the class passes verification, it moves to preparation where memory is allocated as needed. During resolution, any other classes that are referenced are resolved. This too can lead to more class loading. Finally, the variables allocated in the resolution stage are initialized. Once the .class is linked and loaded, new instances can be created. These instances of type 'Class' provide access to methods, fields and constructors of the class. This functionality is relied upon for reflection.

The JVM takes care of class loading with Classloaders. There are a few, and they run in sequence. Some are platform, and other can be custom written.  

* Primordial, Extension and Application are platform classloaders
* EE and Framework classloaders are examples of custom classloaders

Custom class loaders typically massage bytecode to weave in extra functionality such as instrumentation or dependency injection.

Bytecode
========
Every language the runs on the JVM is converted to bytecode during the compilation process. Every operation fits in a byte (less than 256 operations), thus the name Bytecode. It's is not java specific, though java turns into bytecode. Bytecode is an intermediate representation that is not machine dependent, and is not as readable or writable as the higher level languages that compile down into bytecode. For example, looping and conditionals don't exist and are replaced with branch instructions. The JVM is responsible for executing bytecode. It's also responsible for making optimizations. Code sections that run often, can be compiled on the fly into machine code. This process is referred to as JIT (Just in-time Compilation)

Here is a link to a list of [bytecode operations](http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings)

If you want to view the bytecode generated by your class, you can use 'javap' which ships with the jdk.

If you look at the .class containing the java code, this is what you would see. I didn't modify it all.

<code>
	public class ByteCodeTutorial {
		private static ByteCodeTutorial instance = null;
		public static void main(String args[]){
			instance = new ByteCodeTutorial();
			System.out.println(instance + " carlo ");
			for(int i=0; i < 5; i++){
				System.out.println(i);
			}
		}
	}
</code>

<pre>
<code>
$javap -c ByteCodeTutorial
Compiled from "ByteCodeTutorial.java"
public class ByteCodeTutorial extends java.lang.Object{
static {};
  Code:
   0:	aconst_null
   1:	putstatic	#10; //Field instance:LByteCodeTutorial;
   4:	return

public ByteCodeTutorial();
  Code:
   0:	aload_0
   1:	invokespecial	#15; //Method java/lang/Object."<init>":()V
   4:	return

public static void main(java.lang.String[]);
  Code:
   0:	new	#1; //class ByteCodeTutorial
   3:	dup
   4:	invokespecial	#20; //Method "<init>":()V
   7:	putstatic	#10; //Field instance:LByteCodeTutorial;
   10:	getstatic	#21; //Field java/lang/System.out:Ljava/io/PrintStream;
   13:	new	#27; //class java/lang/StringBuilder
   16:	dup
   17:	invokespecial	#29; //Method java/lang/StringBuilder."<init>":()V
   20:	getstatic	#10; //Field instance:LByteCodeTutorial;
   23:	invokevirtual	#30; //Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
   26:	ldc	#34; //String  carlo 
   28:	invokevirtual	#36; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   31:	invokevirtual	#39; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;
   34:	invokevirtual	#43; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   37:	iconst_0
   38:	istore_1
   39:	goto	52
   42:	getstatic	#21; //Field java/lang/System.out:Ljava/io/PrintStream;
   45:	iload_1
   46:	invokevirtual	#49; //Method java/io/PrintStream.println:(I)V
   49:	iinc	1, 1
   52:	iload_1
   53:	iconst_5
   54:	if_icmplt	42
   57:	return
}
</code>
</pre>

I'm not going to walk thru this bytecode, but looking at this small code you can map it by looking up what opcodes do. I will highlight a few things:

* You can see that string concatenation creates a new string builder. This is why you should always just create a StringBuilder if you're going to be doing a bunch of concats.
* You can see there is no looping
* You can also see the constant pool by running javap -verbose