<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <title>JVM Platform Usefulness</title>
   <meta name="author" content="Carlo Barbara" />

   <!-- syntax highlighting CSS -->
   <link rel="stylesheet" href="/blog/css/syntax.css" type="text/css" />

   <!-- Homepage CSS -->
   <link rel="stylesheet" href="/blog/css/screen.css" type="text/css" media="screen, projection" />

   <!-- Typekit -->
   <script type="text/javascript" src="http://use.typekit.com/jpd0pfm.js"></script>
   <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body>

<!-- ClickTale Top part -->
<script type="text/javascript">
var WRInitTime=(new Date()).getTime();
</script>
<!-- ClickTale end of Top part -->

<div class="site">
  <div class="title">
    <a href="/blog">CAB's Kata</a>
  </div>
  
  <div id="post">
<p>I have been reacquainting myself with some of the JVM internals. None of this knowledge directly changes how I work day to day, but it's still useful to know when the situation arises. I'm writing this one so I have a nice summary for myself. For a good read that covers these topics in more detail, I suggest reading "The Well-Grounded Java Developer - Evans &amp; Verburg."</p>

<h1>Classloading</h1>

<p>Classloading is the process by which the JVM loads custom code and types. When you compile your <em>.java source, you end up with </em>.class files. These *.class file contain bytecode, which I'll talk more about in a bit. For the JVM to create a new instance of your custom type, the .class file needs to be loaded and linked. Loading happens when the JVM reads the byte stream from disk that lives in the .class file, and then creates an instance of the 'Class' type. The next step is Linking, which happens in 4 phases (Verification, Preparation, Resolution, and Initialization). Verification checks things such access controls, type validations, and bytecode stack checks. Once the class passes verification, it moves to preparation where memory is allocated as needed. During resolution, any other classes that are referenced are resolved. This too can lead to more class loading. Finally, the variables allocated in the resolution stage are initialized. Once the .class is linked and loaded, new instances can be created. These instances of type 'Class' provide access to methods, fields and constructors of the class. This functionality is relied upon for reflection.</p>

<p>The JVM takes care of class loading with Classloaders. There are a few, and they run in sequence. Some are platform, and other can be custom written.</p>

<ul>
<li>Primordial, Extension and Application are platform classloaders</li>
<li>EE and Framework classloaders are examples of custom classloaders</li>
</ul>


<p>Custom class loaders typically massage bytecode to weave in extra functionality such as instrumentation or dependency injection.</p>

<h1>Bytecode</h1>

<p>Every language the runs on the JVM is converted to bytecode during the compilation process. Every operation fits in a byte (less than 256 operations), thus the name Bytecode. It's is not java specific, though java turns into bytecode. Bytecode is an intermediate representation that is not machine dependent, and is not as readable or writable as the higher level languages that compile down into bytecode. For example, looping and conditionals don't exist and are replaced with branch instructions. The JVM is responsible for executing bytecode. It's also responsible for making optimizations. Code sections that run often, can be compiled on the fly into machine code. This process is referred to as JIT (Just in-time Compilation)</p>

<p>Here is a link to a list of <a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">bytecode operations</a></p>

<p>If you want to view the bytecode generated by your class, you can use 'javap' which ships with the jdk.</p>

<p>If you look at the .class containing the java code, this is what you would see. I didn't modify it all.</p>

<p><code></p>

<pre><code>public class ByteCodeTutorial {
    private static ByteCodeTutorial instance = null;
    public static void main(String args[]){
        instance = new ByteCodeTutorial();
        System.out.println(instance + " carlo ");
        for(int i=0; i &lt; 5; i++){
            System.out.println(i);
        }
    }
}
</code></pre>

<p></code></p>

<pre><code>
  Constant pool:
const #1 = class  #2;   //  ByteCodeTutorial
const #2 = Asciz  ByteCodeTutorial;
const #3 = class  #4;   //  java/lang/Object
const #4 = Asciz  java/lang/Object;
const #5 = Asciz  instance;
const #6 = Asciz  LByteCodeTutorial;;
const #7 = Asciz  <clinit>;
const #8 = Asciz  ()V;
const #9 = Asciz  Code;
const #10 = Field #1.#11;  //  ByteCodeTutorial.instance:LByteCodeTutorial;
const #11 = NameAndType #5:#6;//  instance:LByteCodeTutorial;
const #12 = Asciz LineNumberTable;
const #13 = Asciz LocalVariableTable;
const #14 = Asciz <init>;
const #15 = Method   #3.#16;  //  java/lang/Object."<init>":()V
const #16 = NameAndType #14:#8;//  "<init>":()V
const #17 = Asciz this;
const #18 = Asciz main;
const #19 = Asciz ([Ljava/lang/String;)V;
const #20 = Method   #1.#16;  //  ByteCodeTutorial."<init>":()V
const #21 = Field #22.#24; //  java/lang/System.out:Ljava/io/PrintStream;
const #22 = class #23;  //  java/lang/System
const #23 = Asciz java/lang/System;
const #24 = NameAndType #25:#26;//  out:Ljava/io/PrintStream;
const #25 = Asciz out;
const #26 = Asciz Ljava/io/PrintStream;;
const #27 = class #28;  //  java/lang/StringBuilder
const #28 = Asciz java/lang/StringBuilder;
const #29 = Method   #27.#16; //  java/lang/StringBuilder."<init>":()V
const #30 = Method   #27.#31; //  java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
const #31 = NameAndType #32:#33;//  append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
const #32 = Asciz append;
const #33 = Asciz (Ljava/lang/Object;)Ljava/lang/StringBuilder;;
const #34 = String   #35;  //   carlo
const #35 = Asciz  carlo ;
const #36 = Method   #27.#37; //  java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
const #37 = NameAndType #32:#38;//  append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
const #38 = Asciz (Ljava/lang/String;)Ljava/lang/StringBuilder;;
const #39 = Method   #27.#40; //  java/lang/StringBuilder.toString:()Ljava/lang/String;
const #40 = NameAndType #41:#42;//  toString:()Ljava/lang/String;
const #41 = Asciz toString;
const #42 = Asciz ()Ljava/lang/String;;
const #43 = Method   #44.#46; //  java/io/PrintStream.println:(Ljava/lang/String;)V
const #44 = class #45;  //  java/io/PrintStream
const #45 = Asciz java/io/PrintStream;
const #46 = NameAndType #47:#48;//  println:(Ljava/lang/String;)V
const #47 = Asciz println;
const #48 = Asciz (Ljava/lang/String;)V;
const #49 = Method   #44.#50; //  java/io/PrintStream.println:(I)V
const #50 = NameAndType #47:#51;//  println:(I)V
const #51 = Asciz (I)V;
const #52 = Asciz args;
const #53 = Asciz [Ljava/lang/String;;
const #54 = Asciz i;
const #55 = Asciz I;
const #56 = Asciz StackMapTable;
const #57 = Asciz SourceFile;
const #58 = Asciz ByteCodeTutorial.java;
</code></pre>


<br>


<pre>
<code>
$javap -c ByteCodeTutorial
Compiled from "ByteCodeTutorial.java"
public class ByteCodeTutorial extends java.lang.Object{
static {};
  Code:
   0:   aconst_null
   1:   putstatic   #10; //Field instance:LByteCodeTutorial;
   4:   return

public ByteCodeTutorial();
  Code:
   0:   aload_0
   1:   invokespecial   #15; //Method java/lang/Object."<init>":()V
   4:   return

public static void main(java.lang.String[]);
  Code:
   0:   new #1; //class ByteCodeTutorial
   3:   dup
   4:   invokespecial   #20; //Method "<init>":()V
   7:   putstatic   #10; //Field instance:LByteCodeTutorial;
   10:  getstatic   #21; //Field java/lang/System.out:Ljava/io/PrintStream;
   13:  new #27; //class java/lang/StringBuilder
   16:  dup
   17:  invokespecial   #29; //Method java/lang/StringBuilder."<init>":()V
   20:  getstatic   #10; //Field instance:LByteCodeTutorial;
   23:  invokevirtual   #30; //Method java/lang/StringBuilder.append:(Ljava/lang/Object;)Ljava/lang/StringBuilder;
   26:  ldc #34; //String  carlo
   28:  invokevirtual   #36; //Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
   31:  invokevirtual   #39; //Method java/lang/StringBuilder.toString:()Ljava/lang/String;
   34:  invokevirtual   #43; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   37:  iconst_0
   38:  istore_1
   39:  goto    52
   42:  getstatic   #21; //Field java/lang/System.out:Ljava/io/PrintStream;
   45:  iload_1
   46:  invokevirtual   #49; //Method java/io/PrintStream.println:(I)V
   49:  iinc    1, 1
   52:  iload_1
   53:  iconst_5
   54:  if_icmplt   42
   57:  return
}
</code>
</pre>


<p>I'm not going to walk thru this bytecode, but looking at this small code you can map it by looking up what opcodes do. I will highlight a few things:</p>

<ul>
<li>The constant table is self referential, each index is 2 bytes long</li>
<li>The numbers on the left column, under 'Code:' represents the byte number in that sequence. As an example, in the main method the 0 byte is a 'new' opcode. Bytes 1 and 2, are constant index point to entry #1 in the constant table.</li>
<li>Entry #1 in the constant table is a class, named ByteCodeTutorial. You can figure out the names by following the links</li>
<li>You can see that string concatenation creates a new StringBuilder. This is why you should always just create a StringBuilder if you're going to be doing a bunch of concats.</li>
<li>You can see there is no looping</li>
<li>You can also see the constant pool by running javap -verbose</li>
</ul>


</div>

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>15 Feb 2013</span> &raquo; <a href="/blog/measure-it.html">Measure it on the JVM, Yammer Metrics + Graphite = Winning</a></li>
    
      <li><span>14 Feb 2013</span> &raquo; <a href="/blog/ditchingyourlb.html">Ditching Your LB</a></li>
    
      <li><span>22 Jan 2013</span> &raquo; <a href="/blog/scalability.html">On Scalability</a></li>
    
  </ul>
</div>
  
  <div class="footer">
    <div class="contact">
      <p>
        Carlo Barbara<br />
      </p>
    </div>
    <div class="contact">
      <p>
        <a href="http://github.com/cab222/">github.com/cab222</a><br />
        <a href="http://twitter.com/carlobarbara/">twitter.com/carlobarbara</a><br />
      </p>
    </div>
  </div>
</div>

<!-- ClickTale Bottom part -->
<div id="ClickTaleDiv" style="display: none;"></div>
<script type="text/javascript">
if(document.location.protocol!='https:')
  document.write(unescape("%3Cscript%20src='http://s.clicktale.net/WRb.js'%20type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
if(typeof ClickTale=='function') ClickTale(206,0.3,"www03");
</script>
<!-- ClickTale end of Bottom part -->

<!-- Google Analytics -->

<!-- Google Analytics end -->

</body>
</html>
